# Firestore Database Schema

This document describes the structure of the Firestore database used by the Personal Notes application.

## Collections

### `notes` Collection

The main collection storing all notes. Each document represents a single note.

#### Document Structure

```javascript
{
  id: string,              // Unique identifier for the note (same as document ID)
  title: string,           // Note title (required)
  content: string,         // Note content/body (required)
  category: string,        // Category/tag for organization (optional, can be empty string)
  tags: array,             // Array of tags (reserved for future use, currently empty array)
  createdAt: timestamp,    // Firestore server timestamp when note was created
  updatedAt: timestamp,    // Firestore server timestamp when note was last modified
  isPinned: boolean,       // Whether the note is pinned to the top (default: false)
  isArchived: boolean      // Whether the note is archived (default: false)
}
```

#### Example Document

```javascript
{
  id: "1698765432123",
  title: "Meeting Notes",
  content: "Discussed project timeline and deliverables.\n\nAction items:\n1. Review design mockups\n2. Schedule client call\n3. Update documentation",
  category: "Work",
  tags: [],
  createdAt: Timestamp(seconds=1698765432, nanoseconds=123000000),
  updatedAt: Timestamp(seconds=1698770000, nanoseconds=456000000),
  isPinned: true,
  isArchived: false
}
```

## Field Details

### `id` (string)
- Unique identifier for the note
- Set to match the Firestore document ID
- Generated by Firestore on document creation
- Immutable after creation

### `title` (string)
- Note title/heading
- Required field (cannot be empty)
- No length limit enforced at database level
- Used in search and sorting

### `content` (string)
- Main body/content of the note
- Required field (cannot be empty)
- No length limit enforced at database level
- Supports multi-line text (line breaks preserved)
- Used in search functionality

### `category` (string)
- Optional categorization field
- Can be empty string
- Used for filtering and organization
- Auto-complete suggestions from existing categories

### `tags` (array)
- Array of strings for future tag functionality
- Currently not implemented in UI (reserved for future use)
- Always initialized as empty array `[]`
- Can be extended for multi-tag support

### `createdAt` (timestamp)
- Firestore server timestamp
- Set automatically when note is created using `firebase.firestore.FieldValue.serverTimestamp()`
- Immutable after creation
- Used for sorting by creation date

### `updatedAt` (timestamp)
- Firestore server timestamp
- Updated automatically on every note modification
- Initially set to same value as `createdAt`
- Used for sorting by modification date (default sort)

### `isPinned` (boolean)
- Flag to pin important notes to the top of the list
- Default: `false`
- Pinned notes always appear before unpinned notes regardless of sort order
- Toggleable via UI

### `isArchived` (boolean)
- Flag to archive completed or old notes
- Default: `false`
- Archived notes are hidden from main view
- Can be viewed in separate "Archived Notes" modal
- Toggleable via UI

## Indexes

Firestore automatically creates indexes for single-field queries. For this application, the following indexes are used:

### Automatic Indexes (Created by Firestore)
- `updatedAt` (descending) - Used for default note ordering
- `createdAt` (descending) - Used for creation date sorting

### No Composite Indexes Required
The current queries don't require composite indexes as we:
- Sort by single field only
- Filter in client-side code for search and category filtering

## Queries Used in Application

### 1. Real-time Listener - Get All Notes
```javascript
db.collection('notes')
  .orderBy('updatedAt', 'desc')
  .onSnapshot(snapshot => { ... });
```
- Returns all notes ordered by most recently updated
- Real-time listener provides instant updates
- Client-side filtering for archived notes, search, and categories

### 2. Create Note
```javascript
db.collection('notes').add({
  title: '...',
  content: '...',
  category: '...',
  tags: [],
  createdAt: firebase.firestore.FieldValue.serverTimestamp(),
  updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
  isPinned: false,
  isArchived: false
});
```

### 3. Update Note
```javascript
db.collection('notes').doc(noteId).update({
  title: '...',
  content: '...',
  category: '...',
  updatedAt: firebase.firestore.FieldValue.serverTimestamp()
});
```

### 4. Delete Note
```javascript
db.collection('notes').doc(noteId).delete();
```

### 5. Toggle Pin/Archive
```javascript
db.collection('notes').doc(noteId).update({
  isPinned: !currentValue,
  updatedAt: firebase.firestore.FieldValue.serverTimestamp()
});
```

## Security Rules

The database is protected by Firestore Security Rules (see `firestore.rules`):

```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /notes/{noteId} {
      allow read, write: if request.auth != null;
    }
  }
}
```

**Security:**
- Only authenticated users can read/write notes
- Uses Firebase Anonymous Authentication
- All authenticated users access the same note collection
- Frontend password provides additional access control

## Data Migration

### From localStorage to Firestore

When migrating from the old localStorage-based system:

**Old Format (localStorage):**
```javascript
{
  id: "1698765432123",
  title: "...",
  content: "...",
  category: "...",
  created: "2023-10-31T10:30:32.123Z",  // ISO string
  modified: "2023-10-31T11:00:00.456Z", // ISO string
  pinned: false,
  archived: false
}
```

**Migration Mapping:**
- `created` → `createdAt` (convert to Date or serverTimestamp)
- `modified` → `updatedAt` (convert to Date or serverTimestamp)
- `pinned` → `isPinned`
- `archived` → `isArchived`
- Add `tags: []` field
- Keep all other fields the same

## Performance Considerations

### Read Operations
- Each page load reads all notes (single query)
- Real-time listener keeps data fresh without additional reads
- Offline persistence caches data locally

### Write Operations
- Each create/update/delete is one write operation
- Batch writes used for migration (efficient for multiple notes)

### Free Tier Limits
- 50,000 reads per day
- 20,000 writes per day
- 1GB storage

For a personal note-taking app with moderate use:
- ~100 notes
- ~50 reads/day (page loads)
- ~10 writes/day (new notes, edits)
- Well within free tier limits

## Future Schema Enhancements

Potential fields to add in future versions:

```javascript
{
  // Existing fields...
  
  // Future fields:
  color: string,           // Color code for visual organization
  reminder: timestamp,     // Reminder/due date
  attachments: array,      // File attachments
  collaborators: array,    // Shared with users
  version: number,         // Version number for history
  parentId: string,        // For nested notes/sub-notes
  order: number,           // Custom ordering
  encrypted: boolean,      // End-to-end encryption flag
  checklistItems: array,   // For todo-list notes
}
```

## Backup and Export

Notes can be exported via the "Export All" feature:

**Export Format (JSON):**
```javascript
{
  exportDate: "2023-10-31T12:00:00.000Z",
  notesCount: 42,
  notes: [
    {
      id: "...",
      title: "...",
      content: "...",
      category: "...",
      tags: [],
      createdAt: "2023-10-31T10:30:32.123Z",  // ISO string
      updatedAt: "2023-10-31T11:00:00.456Z",  // ISO string
      isPinned: false,
      isArchived: false
    },
    // ... more notes
  ]
}
```

This format can be used to:
- Backup notes to local storage
- Import into another Firebase project
- Archive old notes
- Data portability

## Troubleshooting

### Missing Timestamps
If `createdAt` or `updatedAt` is `null`:
- The write may not have synced to the server yet
- Check for pending writes in snapshot metadata
- The app falls back to `new Date()` for display

### Document ID Mismatch
The `id` field should always match the document ID:
- Always set `id: docRef.id` when creating documents
- Use consistent IDs during migration

### Query Performance
If queries become slow with many notes:
- Consider pagination (limit queries)
- Add indexes for frequently filtered fields
- Archive old notes regularly
